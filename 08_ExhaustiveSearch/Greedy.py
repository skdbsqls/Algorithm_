# Greedy
# 결정이 필요할 때, 현재 기준으로 가장 좋아보이는 선택지로 결정하여 답을 도출하는 알고리즘

# Greedy 문제의 특징(푸는 방법)
# 조건을 확인하기 전에 선행되어야 하는 것
# 규칙성을 찾아야 한다 -> 규칙을 찾지 못 하면 풀 수 없다!

# Greedy로 풀 수 있는 조건
# 1. 탐욕적 선택 조건(Greedy Choice Property)
#   : 각 단계의 최적해 선택이 이후 단계의 선택에 영향을 주지 않는다.
#   : 즉, 각 단계의 규칙이 변하면 안 된다. 규칙대로만 풀었을 때 결과가 나와야만.
# 2. 최적 부분 구조(Optimal Substructure)
#   : 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이어야 한다.


# [문제: 동전교환]
# 4가지 종류의 동전(10, 50, 100, 500)이 있다.
# 손님의 돈을 최소한의 동전 수를 사용하여 교환해주고자 한다.
# 만약 1730월을 거슬러주기 위해 사용할 수 있는 최소 동전 수는 몇 개인가?
coin_list = [500, 100, 50, 10]  # 큰 동전부터 작성
target = 1730
cnt = 0

for coin in coin_list:
    possible_cnt = target // coin  # 현재 동전으로 가능한 최대 수
    cnt += possible_cnt  # 정답에 더해줌
    target -= coin * possible_cnt  # 금액을 빼줌

print(cnt)


# [문제: 화장실]
# 기숙사에는 하나의 화장실만 존재한다.
# A, B, C, D의 학생은 각자 평균 화장실 사용 시간이 (A: 15, B: 30, C: 50, D: 10)이다.
# 만약, A가 먼저 화장실을 이용한다면, 나머지 인원은 대기를 해야한다.
# 나머지 B, C, D 각자의 대기시간들의 총합은 15 * 3 = 45분이다.
# 이 문제를 그리디로 풀 경우, 어떤 기준으로 접근해야 대기시간의 누적합이 최소가 될까.
# [참고] 그리디는 정렬과 함께 하는 경우가 많다.
people = [15, 30, 50, 10]
n = len(people)

# 규칙 : 최소 시간인 사람부터 화장실로 들어가자.
people.sort()  # 오름차순 정렬

total_time = 0  # 전체 대기 시간
remain_people = n - 1  # 대기인원 수

for turn in range(n):
    time = people[turn]
    total_time += time * remain_people
    remain_people -= 1

print(total_time)


# [문제: 0-1 Knapsack]
# 도둑은 보물들이 있는 창고에 침입했다. 도둑은 최대 30kg까지 짐을 담아갈 수 있다.
# 물건의 개수(N) 그리고 물건 별 무게(W)와 가격(P)이 주어질 때,
# 어떤 물건을 담아야 도둑이 최대 이득을 볼 수 있을지 구하라.

# -> kg 당 가격이 가장 높은 물건을 최대한 담기
# kg 당 가격으로 어떻게 정렬할까? (sort)


# [문제: 회의실 배정]
# 회의실이 하나인 회사가 있다. 여러 팀들이 원하는 회의식 예약 시간이 주어질 때,
# 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정해야 할까?
# [입력] 희망 회의 개수, 시작 시간, 종료 시간
# -> 회의 종료시간이 가장 빠른 회의를 먼저 선택하자!
# 1. 끝나는 시간을 기준으로 오름차순 정렬하기
# 2. 빠르게 끝나는 회의를 선택하여 확정하기
# 3. 이후로 가능한 회의 중 빠르게 끝나는 회의 선택해서 확정하기




