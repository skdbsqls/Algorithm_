# [연습문제] 다음 이진 트리 표현에 대하여 전위 순회하여 정점의 번호를 출력하시오.
#  V = 트리의 정점의 총 개수
#  V - 1 = 간선의 총 개수
#  * 간선은 항상 '부모-자식' 순서로 표기 된다.

'''
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
'''
N = int(input())  # 1번부터 N번까지의 정점
E = N - 1  # 간선 수
arr = list(map(int, input().split()))  # 간선의 정보


# 전위 순회: 방문한 정점(부모) 먼저 처리
def pre_order(T):
    if T:  # 0이 아니면(존재하는 정점이면)
        print(T)  # visit(T) T에서 할 일 처리
        pre_order(left[T])  # 왼쪽 자식(서브트리)로 이동
        pre_order(right[T])  # 오른쪽 자식(서브트리)로 이동


# 중위 순회
def in_order(T):
    if T:  # 0이 아니면(존재하는 정점이면)
        in_order(left[T])  # 왼쪽 자식(서브트리)로 이동
        print(T)  # visit(T) T에서 할 일 처리
        in_order(right[T])  # 오른쪽 자식(서브트리)로 이동


# 후위 순회
def post_order(T):
    if T:  # 0이 아니면(존재하는 정점이면)
        post_order(left[T])  # 왼쪽 자식(서브트리)로 이동
        post_order(right[T])  # 오른쪽 자식(서브트리)로 이동
        print(T)  # visit(T) T에서 할 일 처리


left = [0] * (N + 1)  # 부모를 인덱스로 왼쪽 자식 저장
right = [0] * (N + 1)  # 부모를 인덱스로 오른쪽 자식 저장
par = [0] * (N + 1)  # 자식을 인덱스로 부모 저장

# 부모를 인덱스로 자식 저장
for i in range(E):
    p, c = arr[i * 2], arr[i * 2 + 1]  # 부모-자식
    if left[p] == 0:  # 왼쪽 자식이 아직 없으면,
        left[p] = c  # 왼쪽 자식으로 저장
    else:  # 왼쪽 자식이 있으면,
        right[p] = c  # 오른쪽 자식으로 저장

# 자식을 인덱스로 부모 저장
for i in range(E):
    p, c = arr[i * 2], arr[i * 2 + 1]  # 부모-자식
    par[c] = p

print(left)  # [0, 2, 4, 5, 7, 8, 10, 12, 0, 0, 0, 13, 0, 0]
print(right)  # [0, 3, 0, 6, 0, 9, 11, 0, 0, 0, 0, 0, 0, 0]
print(par)  # [0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 11]

# 루트 찾기
root = 1
for i in range(1, N + 1):
    if par[i] == 0:  # 부모 정점이 없으면
        root = i
        break

# 루트부터 전위순회
pre_order(root)

# 1번부터 전위순회
pre_order(1)  # 1 2 4 7 12 3 5 8 9 6 10 11 13
# 6번부터 전위순회
pre_order(6)  # 6 10 11 13

# 1번부터 중위순회
in_order(1)  # 12 7 4 2 1 8 5 9 3 10 6 13 11

# 1번부터 후위순회
post_order(1)  # 12 7 4 2 8 9 5 10 13 11 6 3 1

#=======================================================================
# [이진 탐색 트리] Binary Search Tree
# - 탐색 작업을 효율적으로 하기 위한 자료구조
# - 모든 원소는 서로 다른 유일한 키를 갖는다.
# - key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
# - 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리이다.
# - 중위 순회하면서 오름차순으로 정렬된 값으로 얻을 수 있다.

# [탐색 연산]
# - 루트에서 시작한다.
# - 탐색할 키 값 x를 루트 노드의 키 값과 비교한다.
# - 서브트리에 대해서 순환적으로 탐색 연산을 반복한다.

# [삽입 연산]
# - 먼저 탐색 연산을 수행한다.
#     - 삽입할 원소와 같은 원소가 ㅌ크리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인한다.
#     - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다.
# - 탐색에서 실패한 위치에 원소를 삽입한다.

# [성능]
# - 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다.
# - 평균의 경우(이진 트리가 균형적으로 생성되어 있는 경우) : O(log n)
# - 최악의 경우(한쪽으로 치우친 경사 이진트리의 경우) : O(n)
#   -> 순차탐색과 시간복잡도가 같다.
