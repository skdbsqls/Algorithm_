# [힙] Heap
# : 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조

# [최대힙] max heap
# - 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
# - 부모노드의 키값 > 자식노드의 키값
# - 루트노드 : 키값이 가장 큰 노드

# [최소힙] min heap
# - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
# - 부모노드의 키값 < 자식노드의 키값
# - 루트노드 : 키값이 가장 작은 노드

# [힙 연산] 삭제
# - 힙에서는 루트노드의 원소만을 삭제 할 수 있다.
# - 루트노드의 원소를 삭제하여 반환한다.
# - 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.

# [힙을 이용한 우선순위 큐]
# - 힙의 키를 우선순위로 활용하여 큐를 구현할 수 있다.

# ==================================================================================================
# [완전이진트리의 전위순회]
def pre_order(n):
    if n <= N:  # 실존하는 정점이면 if T:
        print(tree[n])  # visit(T)
        pre_order(n * 2)  # pre_order(left[T])
        pre_order(n * 2 + 1)  # pre_order(right[T])


N = 9  # 완전이진트리 정점 수
tree = [0, 33, 31, 27, 21, 22, 18, 23, 14, 19]
pre_order(1)  # 33 31 21 14 19 22 27 18 23


# [최대힙] 99개의 값을 저장할 수 있는 최대힙 만들기
# 삽입 연산
def enqueue(n):
    global last  # 마지막 정점
    last += 1
    heap[last] = n  # 마지막 정점에 n 저장

    c = last  # 부모의 키값과 비교하기 위해
    p = c // 2  # 부모 정점 번호 계산
    while p and heap[p] < heap[c]:  # 부모가 있으면서, 부모 < 자식이면(최대힙 조건에 위반)
        heap[p], heap[c] = heap[c], heap[p]
        c = p  # 현재의 부모를 자식으로
        p = c // 2  # 부모의 부모 정점 번호 계산


# 삭제 연산
def dequeue():
    global last
    temp = heap[1]  # 루트 백업
    heap[1] = heap[last]  # 삭제할 노드의 키를 루트에 복사
    last -= 1  # 마지막 노드 삭제
    p = 1  # 루트에 옮긴 값을 자식과 비교
    c = p * 2  # 왼쪽 자식(자식이 있다면 무조건 왼쪽 자식부터 있으니까, 완전이진트리에서는 오른쪽 자식만 있는 경우는 없음)

    while c <= last:  # 자식이 하나라도 있으면(자식과 비교해야 함)
        if c + 1 <= last and heap[c] < heap[c + 1]:  # 오른쪽 자식도 있고, 오른쪽 자식이 더 크다면,
            c += 1  # 비교 대상을 오른쪽 자식으로 정함
        if heap[p] < heap[c]:  # 자식이 더 크면 최대힙 규칙에 어긋나므로
            heap[p], heap[c] = heap[c], heap[p]  # 부모노드와 자식노드 교환
            p = c  # 자식을 새로운 부모로
            c = p * 2  # 왼쪽 자식 번호 계산
        else:
            break
    return temp


heap = [0] * 100
last = 0

enqueue(2)
enqueue(5)
enqueue(7)
enqueue(3)
enqueue(4)
enqueue(6)

print(heap)  # [0, 7, 4, 6, 2, 3, 5, 0, 0,,,]

while last:
    print(dequeue())  # 7 6 5 4 3 2