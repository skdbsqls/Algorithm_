# Memoization(메모이제이션)
# : 메모이제이션은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여
# : 전체적인 실행속도를 빠르게 하는 기술이다.
# : 동적 계획법의 핵심이 되는 기술이다.

# Memoization을 적용한 알고리즘
n = 10
cnt = 0  # 호출 횟수

memo = [0] * (n + 1)
memo[0] = 0
memo[1] = 1

# n번째 피보나치 수를 반환하는 함수
def fibo_memo(n):
    global cnt
    cnt += 1

    # n이 2보다 크거나 같고(0, 1의 결과는 알고 있기 때문), 아직 결과를 확인한 적이 없는 n이라면
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo_memo(n-1) + fibo_memo(n-2)
    # 위의 if 문이 끝나면 memo[n]은 무조건 0이 아님
    # 아래서 그걸 반환
    return memo[n]


print(fibo_memo(n), cnt)  # 55 19



# DP, Dynamic Programming(동적 계획)
# : 동적 계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
# : 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에
# : 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여,
# : 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

# DP 적용하기
# 1) 문제를 부분 문제로 분할한다.
# 2) 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구한다.
# 3) 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.

# DP를 적용한 알고리즘
def fibo_dp(n):
    # 작은 n의 결과를 담기 위한 배열
    fibo = [0] * (n + 1)

    # fibo[0] == 0이고, fibo[1] == 1이다.
    fibo[0] = 0
    fibo[1] = 1

    # 2부터 n까지 보면서 dp 배열을 채워 나간다.
    for i in range(2, n + 1):
        fibo[i] = fibo[i - 1] + fibo[i - 2]

    # 우리가 구할 n번째 피보나치 수는 fibo[n]에 있다.
    return fibo[n]


print(fibo_dp(n))  # 55

# DP의 구현 방식
# - recursive(재귀, 하향식, 메모이제이션) 방식
# - iterative(상향식, 반복) 방식 <- 여기가 더 가까움

# - Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다.
# - 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.



# DFS(Depth First Search, 깊이 우선 탐색)
# - 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다.
    # - 비선형구조 탐색 방법 두 가지 : DFS, BFS(너비 우선 탐색)
# - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면,
# - 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여
# - 결국 모든 정점을 방문하는 순회 방법
# - 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택을 사용한다.

# DFS 알고리즘
# 1. 시작 정점 v를 결정하여 방문한다.
# 2. 정점 v에 인접한 정점 중에서
    # 1) 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 반복한다.
    # 2) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점 v로 하여 반복한다.
# 3. 스택이 공백이 될 때까지 반복한다.

# [연습문제] 연결되어 있는 두 개의 정점 사이의 간선을 순서대로 나열 해 놓은 것을 보고,
#           모든 정점을 깊이 우선 탐색하여 화면에 깊이 우선 탐색 경로를 출력하시오. (정점은 1로 시작하시오)
'''
7 8
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
'''
V, E = map(int, input().split())
graph = list(map(int, input().split()))

adj_list = [[] for _ in range(V + 1)]  # 인접 리스트

# 1. 인접 리스트 채우기
for i in range(E):
    v, w = graph[i * 2], graph[i * 2 + 1]  # 두 개씩 읽어 오는 방법
                                           # [참고] 인덱스를 2칸씩 올리고, i와 i+1을 활용할 수도 있음
    adj_list[v].append(w)

# 2. DFS 탐색하기
def dfs(v, N):
    visited = [0] * (N + 1)  # 방문 표시
    stack = []

    while True:
        if visited[v] == 0:  # 첫 방문이면, (뒤로 가서 재방문 한건지, 첫 방문인지 구분)
            visited[v] = 1
            print(v)  # 처음 방문했을 때만 출력

        for w in adj_list[v]:
            if visited[w] == 0:  # v에 인접하고 방문 안 한 W가 있으면,
                stack.append(v)  # 현재 위치를 스택에 담고,
                v = w  # 현재 위치 이동
                break

        # v에 인접한 모든 w를 방문했다면,
        else:
            if stack:  # 스택이 비어 있지 않다면, 돌아갈 곳이 있다는 말
                v = stack.pop()
            else:  # 스택이 비어 있다면, 돌아갈 곳이 없다는 말, 즉 탐색 끝!
                break  # while을 중단 시키는 break


